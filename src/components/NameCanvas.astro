---
// No server-side code needed for this component
---

<div class="name-canvas-container">
    <!-- SEO and accessibility text -->
    <h1 class="sr-only">Yuval Adam</h1>
    <span class="seo-text">Yuval Adam - Software Engineer, Developer, Tech Enthusiast</span>
    
    <!-- Canvas element -->
    <canvas 
        id="nameCanvas" 
        class="cursor-pointer mx-auto block" 
        role="img" 
        aria-label="Yuval Adam - Animated Logo"
        title="Yuval Adam"
    ></canvas>
    
    <!-- Fallback for browsers without JavaScript -->
    <noscript>
        <div class="fallback-text">
            <h1 class="text-4xl font-bold font-serif text-center text-gray-800">Yuval Adam</h1>
        </div>
    </noscript>
</div>

<script>
class NameCanvas {
    constructor() {
        this.canvas = document.getElementById('nameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.pixels = [];
        this.animationId = null;
        
        // Responsive canvas dimensions
        this.setResponsiveDimensions();
        this.dpr = window.devicePixelRatio || 1;
        
        // Animation properties
        this.time = 0;
        this.hovering = false;
        
        this.init();
        this.setupResponsive();
    }
    
    drawHexagon(x, y, size) {
        const angle = Math.PI / 3; // 60 degrees
        this.ctx.beginPath();
        
        for (let i = 0; i < 6; i++) {
            const xPos = x + size * Math.cos(angle * i);
            const yPos = y + size * Math.sin(angle * i);
            
            if (i === 0) {
                this.ctx.moveTo(xPos, yPos);
            } else {
                this.ctx.lineTo(xPos, yPos);
            }
        }
        
        this.ctx.closePath();
    }
    
    setResponsiveDimensions() {
        // Get the container's dimensions instead of using fixed sizes
        const container = this.canvas.parentElement;
        const containerRect = container.getBoundingClientRect();
        
        // Use container width with minimal padding, height based on font size
        const viewportWidth = window.innerWidth;
        
        if (viewportWidth < 480) {
            // Mobile
            this.width = Math.max(280, containerRect.width || 280);
            this.height = 60;
            this.fontSize = 38;
        } else if (viewportWidth < 768) {
            // Tablet  
            this.width = Math.max(350, containerRect.width || 350);
            this.height = 70;
            this.fontSize = 48;
        } else {
            // Desktop
            this.width = Math.max(400, containerRect.width || 400);
            this.height = 80;
            this.fontSize = 56;
        }
    }
    
    setupResponsive() {
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                this.setResponsiveDimensions();
                this.init();
            }, 250);
        });
    }
    
    init() {
        // Set canvas size with high DPI support
        this.canvas.width = this.width * this.dpr;
        this.canvas.height = this.height * this.dpr;
        this.canvas.style.width = this.width + 'px';
        this.canvas.style.height = this.height + 'px';
        
        // Scale context for crisp rendering
        this.ctx.scale(this.dpr, this.dpr);
        
        // Enable text smoothing
        this.ctx.textRenderingOptimization = 'optimizeQuality';
        this.ctx.imageSmoothingEnabled = true;
        this.ctx.imageSmoothingQuality = 'high';
        
        // Generate pixels from text
        this.generatePixels();
        
        // Start animation
        this.animate();
        
        // Add hover events
        this.canvas.addEventListener('mouseenter', () => {
            this.hovering = true;
        });
        
        this.canvas.addEventListener('mouseleave', () => {
            this.hovering = false;
        });
    }
    
    generatePixels() {
        // Create temporary canvas for text rendering
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        
        // High resolution for crisp text
        const scale = 2;
        tempCanvas.width = this.width * scale;
        tempCanvas.height = this.height * scale;
        tempCtx.scale(scale, scale);
        
        // High-quality text rendering
        tempCtx.textRenderingOptimization = 'optimizeQuality';
        tempCtx.imageSmoothingEnabled = true;
        tempCtx.imageSmoothingQuality = 'high';
        
        // Set font and draw text (responsive, full width usage)
        tempCtx.font = `bold ${this.fontSize}px Lora, serif`;
        tempCtx.fillStyle = '#000';
        tempCtx.textAlign = 'left';
        tempCtx.textBaseline = 'middle';
        
        // Measure text to optimize positioning
        const textMetrics = tempCtx.measureText('Yuval Adam');
        const textWidth = textMetrics.width;
        const xPosition = Math.max(5, (this.width - textWidth) / 2); // Center with minimal margin
        
        tempCtx.fillText('Yuval Adam', xPosition, this.height / 2);
        
        // Get image data
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const data = imageData.data;
        
        // Extract pixels with better sampling
        this.pixels = [];
        const pixelSize = 2; // Smaller for better text clarity
        
        for (let y = 0; y < this.height * scale; y += pixelSize * scale) {
            for (let x = 0; x < this.width * scale; x += pixelSize * scale) {
                const index = (y * tempCanvas.width + x) * 4;
                const alpha = data[index + 3];
                
                if (alpha > 128) { // If pixel is not transparent
                    this.pixels.push({
                        x: x / scale,
                        y: y / scale,
                        originalX: x / scale,
                        originalY: y / scale,
                        size: Math.random() * 0.8 + 1.5, // Smaller, more consistent sizes
                        speed: Math.random() * 0.01 + 0.005,
                        offset: Math.random() * Math.PI * 2,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.005, // Much slower rotation
                        color: `hsl(${200 + Math.random() * 30}, 70%, ${45 + Math.random() * 15}%)` // More consistent colors
                    });
                }
            }
        }
    }
    
    animate() {
        this.time += 0.02;
        
        // Clear canvas with better clearing
        this.ctx.clearRect(0, 0, this.width, this.height);
        
        // Draw pixels
        this.pixels.forEach((pixel, index) => {
            // Very subtle animation effects
            const wave = Math.sin(this.time + pixel.offset) * 0.5; // Much smaller wave
            const pulse = Math.sin(this.time * 1.5 + index * 0.15) * 0.1 + 1; // Subtle pulse
            
            if (this.hovering) {
                // Gentle scatter effect on hover
                pixel.x += (Math.random() - 0.5) * 1;
                pixel.y += (Math.random() - 0.5) * 1;
                
                // Gradually return to original position
                pixel.x += (pixel.originalX - pixel.x) * 0.15;
                pixel.y += (pixel.originalY - pixel.y) * 0.15;
            } else {
                // Very gentle wave animation
                pixel.x = pixel.originalX + wave;
                pixel.y = pixel.originalY + Math.sin(this.time + pixel.offset * 2) * 0.3;
            }
            
            // Very subtle rotation update
            pixel.rotation += pixel.rotationSpeed;
            
            // Draw hexagon with better anti-aliasing
            this.ctx.save();
            this.ctx.globalAlpha = 0.9;
            
            // Apply rotation
            this.ctx.translate(pixel.x, pixel.y);
            this.ctx.rotate(pixel.rotation);
            
            // Draw hexagon
            this.drawHexagon(0, 0, pixel.size * pulse);
            this.ctx.fillStyle = pixel.color;
            this.ctx.fill();
            
            // Add subtle glow effect
            if (this.hovering) {
                this.ctx.globalAlpha = 0.3;
                this.ctx.shadowColor = pixel.color;
                this.ctx.shadowBlur = 8;
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            this.ctx.restore();
        });
        
        this.animationId = requestAnimationFrame(() => this.animate());
    }
    
    destroy() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new NameCanvas();
});
</script>

<style>
    .name-canvas-container {
        position: relative;
        display: inline-block;
        width: auto;
        min-width: 280px;
    }
    
    #nameCanvas {
        display: block;
        background: transparent;
        width: 100%;
        height: auto;
    }
    
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
    }
    
    .seo-text {
        position: absolute;
        left: -9999px;
        width: 1px;
        height: 1px;
        overflow: hidden;
    }
    
    .fallback-text {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100px;
        padding: 1rem;
    }
    
    /* Responsive adjustments */
    @media (max-width: 480px) {
        .name-canvas-container {
            min-width: 280px;
        }
        .fallback-text h1 {
            font-size: 2.5rem;
        }
    }
    
    @media (max-width: 768px) {
        .name-canvas-container {
            min-width: 300px;
        }
        .fallback-text h1 {
            font-size: 3rem;
        }
    }
</style>